# -*- coding: utf-8 -*-
"""WS_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Dgsw9m0SsaBVe66bsjI-Cr1VrDa2yH-a
"""

import matplotlib.pyplot as plt
import math as m
import operator as op
from functools import reduce
import scipy.stats as stats
from statistics import mean

"""## **Question 1**

**a_0 = 0**
"""

def func(r, a, n):
  return (r**n * a)

"""Case 1 -> r = 0"""

r1 = 0
n1 = 20
a_0 = 0
ans = []

for i in range(1, n1+1):
  ans.append(func(r1, a_0, i))

x = [i for i in range(1, n1+1)]

plt.plot(x, ans)

"""Case 2 -> 0 < r < 1"""

r2 = [0.2, 0.4, 0.6, 0.8]
n2 = 20
ans = []

for i in r2:
  temp = []

  for j in range(1, n2+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n2+1)]

for i in range(len(r2)):
  plt.plot(x, ans[i])

"""Case 3 -> -1 < r < 0"""

r3 = [-0.2, -0.4, -0.6, -0.8]
n3 = 20
ans = []

for i in r3:
  temp = []

  for j in range(1, n3+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n3+1)]

for i in range(len(r3)):
  plt.plot(x, ans[i])

"""Case 4 -> mod(r) > 1"""

r4 = [-2, -4, 6, 8]
n4 = 20
ans = []

for i in r4:
  temp = []

  for j in range(1, n4+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n4+1)]

for i in range(len(r4)):
  plt.plot(x, ans[i])

"""Analysing all the cases, we can conclude that since the base value (a_0) is 0, irrespective the values that r takes, the graph is a constant graph with all values mapping to 0.

**a_0 = 50**

Case 1 -> r = 0
"""

r1 = 0
n1 = 20
a_0 = 50
ans = []

for i in range(1, n1+1):
  ans.append(func(r1, a_0, i))

x = [i for i in range(1, n1+1)]

plt.plot(x, ans)

"""Since r is 0, all values are 0

Case 2 -> 0 < r < 1
"""

r2 = [0.2, 0.4, 0.6, 0.8]
n2 = 20
ans = []

for i in r2:
  temp = []

  for j in range(1, n2+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n2+1)]

for i in range(len(r2)):
  plt.plot(x, ans[i])

"""It is a decreasing graph that flattens to 0 after 15

Case 3 -> -1 < r < 0
"""

r3 = [-0.2, -0.4, -0.6, -0.8]
n3 = 20
ans = []

for i in r3:
  temp = []

  for j in range(1, n3+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n3+1)]

for i in range(len(r3)):
  plt.plot(x, ans[i])

"""This is an oscillating graph that finally converges to 0

Case 4 -> mod(r) > 1
"""

r4 = [-2, -4, 6, 8]
n4 = 20
ans = []

for i in r4:
  temp = []

  for j in range(1, n4+1):
    temp.append(func(i, a_0, j))

  ans.append(temp)

x = [i for i in range(1, n4+1)]

for i in range(len(r4)):
  plt.plot(x, ans[i])

"""It is consistent at 0, peaking for values after 16 for a case

## **Question 2**

Recurrence relation is : a_n+1 = 0.5*a_n + a_0

Case 1 - a_0 = 0.1
"""

def func(n, a_0):
  temp = [a_0]

  for i in range(1, n+1):
    val = (temp[-1] * 0.5) + a_0
    temp.append(val)

  return temp

ans1 = func(20, 0.1)
ans1

ans2 = func(20, 0.2)
ans2

ans3 = func(20, 0.3)
ans3

plt.plot(ans1)
plt.plot(ans2)
plt.plot(ans3)

"""It is an increasing graph for all the different a_0 values as mentioned in the question. Around the value 5, it starts becoming a constant value ie a stable graph

## **Functions Required**
"""

def forward_diff_table(arr, ans, n):
  temp = []

  for i in range(1, n):
    temp.append(arr[i] - arr[i-1])

  ans.append(temp)
  ans

  while len(ans[-1]) > 1:
    temp = []

    for i in range(1, len(ans[-1])):
      temp.append(ans[-1][i] - ans[-1][i-1])

    ans.append(temp)

  return ans

def ncr(n, r):
  val = 1

  for i in range(r):
    val *= (n - i)

  if r == 1:
    return val

  a = val / m.factorial(r)
  
  return a

def forward_interpolation(y_0, n, ans, u):
  val = y_0

  for i in range(n):
    val += ncr(u, i+1) * ans[i][0]

  return val

"""## **Question 3**"""

n = [i for i in range(1, 17)]
an = [3, 6, 11, 21, 32, 47, 65, 87, 112, 110, 171, 204, 241, 282, 325, 376]
length = len(an)
ans = forward_diff_table(an, [], length)

ans

k = 1

for i in ans:
  plt.plot(i, label = "diff - " + str(k))
  k += 1

plt.legend()

plt.plot(ans[0])

"""It is almost linear with some exception though"""

def function_interpolation(x, x0, h, ans, length, y):
  u = (x - x0) / h  
  print(u)
  return forward_interpolation(y[0], length, ans, u)

error = []
x0 = n[0]
h = 1

for i in range(len(an)):
  u = (n[i] - x0) / h  
  y_hat = forward_interpolation(an[0], len(ans), ans, u)
  error.append(an[i] - y_hat)

error

plt.plot(error)

"""No error

## **Question 4**
"""

force = [i for i in range(10, 100, 10)]
stretch = [19, 57, 94, 134, 173, 216, 256, 297, 343]
n = len(stretch)
ans = forward_diff_table(stretch, [], n)

ans

values_pred = []

for i in range(len(force)):
  x = force[i]
  h = 10
  x_0 = force[0]

  u = (x - x_0) / h
  #print(u)

  interpolated_value = forward_interpolation(stretch[0], len(ans), ans, u)
  values_pred.append(interpolated_value)

values_pred

plt.plot(force, values_pred)

vals = []
x_vals = [15, 17, 85]

x = 15
h = 10
x_0 = force[0]

u = (x - x_0) / h
print(u)

interpolated_value = forward_interpolation(stretch[0], len(ans), ans, u)
interpolated_value
vals.append(interpolated_value)

x = 17
h = 10
x_0 = force[0]

u = (x - x_0) / h
print(u)

interpolated_value = forward_interpolation(stretch[0], len(ans), ans, u)
interpolated_value
vals.append(interpolated_value)

x = 85
h = 10
x_0 = force[0]

u = (x - x_0) / h
print(u)

interpolated_value = forward_interpolation(stretch[0], len(ans), ans, u)
interpolated_value
vals.append(interpolated_value)

vals

plt.plot(force, values_pred, color = "blue")
plt.plot(x_vals, vals, color = "red", marker = "o")

predicted_stretch = []

for i in range(len(force)):
  u = (force[i] - x_0) / h
  predicted_stretch.append(forward_interpolation(stretch[0], len(ans), ans, u))

predicted_stretch

error = []

for i in range(len(force)):
  x = force[i]
  h = 10
  x_0 = force[0]

  u = (x - x_0) / h
  y_hat = forward_interpolation(stretch[0], len(ans), ans, u)

  error.append(stretch[i] - y_hat)

error

plt.plot(error)

"""No error"""

t_statistic, p_value = stats.ttest_ind(a = stretch, b = predicted_stretch, equal_var = True)
print(t_statistic , p_value)